-- Enable UUID extension if not enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Create a table to track user roles (Admin vs User)
CREATE TABLE IF NOT EXISTS public.user_roles (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'user')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS on user_roles
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Allow everyone to read roles (to check if they are admin)
CREATE POLICY "Read roles" ON public.user_roles FOR SELECT USING (true);
-- Only admins can manage roles (but initial setup might need a bypass or manual insert)
-- For now, let's allow read only. Writing is done by manual script or admin function.

-- 2. Create document_permissions table
CREATE TABLE IF NOT EXISTS public.document_permissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    node_id BIGINT REFERENCES public.documents("nodeID") ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    access_level TEXT NOT NULL CHECK (access_level IN ('read_only', 'full_access')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(node_id, user_id)
);

-- Enable RLS on document_permissions
ALTER TABLE public.document_permissions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can see permissions assigned to them
CREATE POLICY "Read own permissions" ON public.document_permissions 
    FOR SELECT USING (auth.uid() = user_id);

-- Policy: Admins can View ALL permissions
-- We need a helper function or a subquery to check admin status to avoid infinite recursion if we query user_roles directly in a complex way, 
-- but simple join is consistent.

-- Let's create a secure view or function to expose user emails for the Admin UI
-- Since we can't query auth.users directly from the client easily for a list.
CREATE OR REPLACE VIEW public.user_profiles_view AS
SELECT id, email 
FROM auth.users;

-- But we need to restrict access to this view to only Admins
-- Views don't have RLS in the same way, so we revoke public access and grant to authenticated, 
-- but we really want application logic or a security definer function.
-- Better approach: A function 'get_all_users' that returns list of users IF the caller is admin.

CREATE OR REPLACE FUNCTION public.get_all_users()
RETURNS TABLE (id UUID, email TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if the calling user is an admin
    IF EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_id = auth.uid() AND role = 'admin'
    ) THEN
        RETURN QUERY SELECT u.id, u.email::text FROM auth.users u;
    ELSE
        RAISE EXCEPTION 'Access Denied: User is not an admin';
    END IF;
END;
$$;

-- 3. Modify Documents RLS to include permission-based access

-- Drop existing restricted policies if they conflict, or we can add OR conditions.
-- Current "Users can read own documents" is: auth.uid() = user_id
-- We want: auth.uid() = user_id OR auth.uid() IN (SELECT user_id FROM document_permissions ...)

DROP POLICY IF EXISTS "Users can read own documents" ON public.documents;
CREATE POLICY "Users can read relevant documents" ON public.documents
    FOR SELECT
    USING (
        auth.uid() = user_id 
        OR 
        EXISTS (
            SELECT 1 FROM public.document_permissions 
            WHERE node_id = public.documents."nodeID" 
            AND user_id = auth.uid()
        )
        OR
        -- Admin sees all? The requirement says "change by administrator", implies admin needs to see them to assign them.
        -- "user can only see the documents he has been approved to see" -> ambiguous if admin can see content or just node structure. 
        -- Usually admin functionality to Assign Nodes implies being able to select them. 
        -- Let's give Admin full read access to all nodes to manage assignments.
        EXISTS (
            SELECT 1 FROM public.user_roles
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );

DROP POLICY IF EXISTS "Users can update own documents" ON public.documents;
CREATE POLICY "Users can update relevant documents" ON public.documents
    FOR UPDATE
    USING (
        auth.uid() = user_id 
        OR 
        EXISTS (
            SELECT 1 FROM public.document_permissions 
            WHERE node_id = public.documents."nodeID" 
            AND user_id = auth.uid() 
            AND access_level = 'full_access'
        )
        OR
        EXISTS (
            SELECT 1 FROM public.user_roles
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    )
    WITH CHECK (
        auth.uid() = user_id 
        OR 
        EXISTS (
            SELECT 1 FROM public.document_permissions 
            WHERE node_id = public.documents."nodeID" 
            AND user_id = auth.uid() 
            AND access_level = 'full_access'
        )
         OR
        EXISTS (
            SELECT 1 FROM public.user_roles
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );

-- Insert the Admin User
-- We need to find the user_id for 'seanbaker513@gmail.com'
-- We can do this in a DO block.

DO $$
DECLARE
    admin_uid UUID;
BEGIN
    SELECT id INTO admin_uid FROM auth.users WHERE email = 'seanbaker513@gmail.com';
    
    IF admin_uid IS NOT NULL THEN
        -- Insert or Update role
        INSERT INTO public.user_roles (user_id, role)
        VALUES (admin_uid, 'admin')
        ON CONFLICT (user_id) DO UPDATE SET role = 'admin';
    END IF;
END $$;

-- Policies for document_permissions table management
-- Admins can Insert/Update/Delete permissions
CREATE POLICY "Admins manage permissions" ON public.document_permissions
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM public.user_roles 
            WHERE user_id = auth.uid() AND role = 'admin'
        )
    );
